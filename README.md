# DataStructure and Algorithm
One stop for Data Structure and Algorithms along with problems related to it. It will help anyone who wants to learn about Data Structure / Algorithm\.



## Data Structures:

###  [1.  Array](https://www.geeksforgeeks.org/array-data-structure/)

    a.	Dynamic Array
    b.	Multi-Dimension Array
    c.	Different Array Problems
    d.	Circular Array
    e.	Java Array methods : Array Slicing etc

###  [2.	Linked List: ](https://www.geeksforgeeks.org/data-structures/linked-list/)

    a.	Singly Linked List
    b.	Doubly Linked List
    c.	Different Linked List Problems
    
### [3.	Stacks: ](https://www.geeksforgeeks.org/stack-data-structure/)

    a.	Design and Implement Stack
    b.	Different Stacks Problems
    
### [4.	Queues: ](https://www.geeksforgeeks.org/queue-data-structure/)

    a.	Design and Implement Queue
    b.	Different Queues Problems
    
### [5.	Hashing: ](https://www.geeksforgeeks.org/hashing-data-structure/)

    a.	Index Mapping or Trivial Hashing
    b.	Separate Chaining for Collision Handling
    c.	Double Hashing
    d.	Hash Map / Hash Table
    e.	Java Hashes
    f.	Different Hashing Problems
    
### 6.	[Trees](https://www.geeksforgeeks.org/binary-tree-data-structure/) | [Graphs](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/)

    a.	Binary Tree
    b.	Binary Search Tree
    c.	Heap
    d.	Trie
    e.	Graphs:
            i. A graph G is an ordered pair of a set V of vertices and a set E of edges. G = (V,E])
            ii. Number of Edges: 
                    1. Directed: |V| = n then 0 <= |E| <= n (n-1)
                    2. Undirected: O <= |E| <= n(n-1)/2
    f.	Shortest Paths
    g.	BFS [Using Queue]
    h.	DFS [Using Stack]
            i. Pre-Order [Root, Left, Right]
            ii. In-Order [Left, Root, Right] -> It gives a sorted list for BST
            iii. Post-Order [Left, Right, Root]
    i.	Dijkstra
    j.	Different Tree/Graph Problems
    
### [7.	Java Collection: ](https://www.javatpoint.com/collections-in-java)

    a.	Set -> HashSet, LinkedHashSet, TreeSet
    b.	List -> LinkedList & ArrayList
    c.	Queue -> Priority Queue (FIFO)
    d.	Deque -> ArrayDeque (FIFO or LIFO)
    e.	Map -> HashMap, LinkedHashMap,TreeMap
    f.	HashTable
    g.	Enum
    h.	Collections Class
    i.	Sorting Collections
    j.	Comparable vs Comparator



## Algorithm:

### [1.	Sorting](https://www.geeksforgeeks.org/sorting-algorithms/)
    a.	Divide and Conquer 
            i. Merge Sort
            ii. Quick Sort
            iii. Heap Sort
    b.	Regular Sort
            i. Bubble Sort – Iterative/Recursive
            ii. Selection Sort
            iii. Insertion Sort – Iterative/Recursive
    c.	Counting Sort
    d.	Java Sorting Built In examples


### [2.	Searching](https://www.geeksforgeeks.org/searching-algorithms/)
    a.	Linear Search
    b.	Binary Search - Iterative/Recursive
    c.	Fibonacci Search
    d.	Java Searching Built in Examples

        
### 3.	[Greedy Method](https://www.geeksforgeeks.org/greedy-algorithms/)


## [Big (O) : ](http://bigocheatsheet.com/)

### [1 < logn < √ n < n < nlogn < n^2 < n^3 < ... < 2^n < 3^n < n^n]

    O(1) – Constant
    O(logn) – Logarithmic
    O(n) – Linear
    O(n2) – Quadratic
    O(n3) – Cubic
    O(2n) – Exponential
    
**Different Algorithms with simple Big(O) analysis**


## [ASCII Char : ](https://www.ascii-code.com/) In Decimal

**[0 - 255] -> [All Characters including extended ASCII]**

**[0 - 31] -> [control char]**

**[32 - 127] -> [printable char]**

**[48 - 57] -> [0 - 9]**

**[65 - 90] -> [A - Z]**

**[97 - 122] -> [a - z]**

**[128 - 255] -> [extended char]**


## Data Measurement

**Data Measurement	Size**

Bit -> Binary Digit (1 or 0)

Byte -> 8 bits

Kilobyte (KB) -> 1,024 Bytes

Megabyte (MB) -> 1,024 Kilobytes

Gigabyte (GB) -> 1,024 Megabytes

Terabyte (TB) -> 1,024 Gigabytes

Petabyte (PB) -> 1,024 Terabytes

Exabyte (EB) -> 1,024 Petabytes

**Java's primitive data types**

byte -> 1 byte | -128 to 127

short -> 2 bytes | -32,768 to 32,767

int -> 4 bytes | -2,147,483,648 to 2,147,483, 647

long -> 8 bytes | -9,223,372,036,854,775,808 to 
9,223,372,036,854,775,807

float -> 4 bytes | approximately ±3.40282347E+38F 
(6-7 significant decimal digits) 
Java implements IEEE 754 standard

double -> 8 bytes | approximately ±1.79769313486231570E+308
(15 significant decimal digits)

char -> 2 byte | 0 to 65,536 (unsigned)




### Learn More

**[Practice Problems](https://leetcode.com/)**

**[Prepare for Interview](https://www.interviewcake.com/)**

